hypothesis_and_feedback: |-
  {% for hypothesis, experiment, feedback in trace.hist %}
  Hypothesis {{ loop.index }}: {{ hypothesis }}
  Observation on the result with the hypothesis: {{ feedback.observations }}
  Feedback on the original hypothesis:  {{ feedback.hypothesis_evaluation }}
  New Feedback for Context (For you to agree or improve upon):  {{ feedback.new_hypothesis }}
  Reasoning for new hypothesis:  {{ feedback.reason }}
  Did changing to this hypothesis work? (focus on the change):  {{ feedback.decision }}
  {% endfor %}

hypothesis_output_format: |-
  The output should follow JSON format. The schema is as follows:
  {
    "hypothesis": "The new hypothesis generated based on the information provided.",
    "reason": "The reason why you generate this hypothesis."
  }

model_hypothesis_specification: |-
  Additional Specifications:
    Hypotheses should grow and evolve based on the previous hypothesis. If there is no previous hypothesis, start with something simple. Gradually Build Up Upon previous hypothesis & feedbacks. 
    Ensure that the hypothesis focuses on the architecture of a PyTorch model. Each hypothesis should address specific architectural choices such as the type of layers, activation functions, regularization techniques, and the overall structure of the model. Avoid hypotheses related to input features or optimization processes.

  Sample Hypotheses (Only learn from the format as these are not the knowledge):
    - "The model should use batch normalization to improve training stability."
    - "The data has spatial dependencies, so we need a 3D CNN."
    - "The model should include dropout layers to prevent overfitting."
    - "The data exhibits long-term dependencies, so we need an LSTM/GRU model."
    - "The model should have three layers. The model should be a ResNet."
    - "The activation function should be ReLU for all hidden layers."
    - "The model should include a fully connected layer at the end."
    - "The model should use a combination of CNN and RNN layers for feature extraction and sequence modeling."

  Remember: if there is no hypothesis, start with something simple like MLP.

  Sample hypothesis evolution loop: (This is the entire loop, see what stage you are at. We want hypothesis to continue growing.) Levels include **Model Type**, **Layer Configuration**, **Activation Functions**, **Regularization Techniques**

  1st Round Hypothesis: The model should be a CNN.

  2nd Round Hypothesis (If first round worked): The model should be a CNN. The CNN should have 5 convolutional layers. (Reasoning: As CNN worked, we now specify the layers specification to grow the hypothesis deeper)

  3rd Round Hypothesis (If second round worked): The model should be a CNN. The CNN should have 5 convolutional layers. Use Leaky ReLU activation for all layers. (Similar Reasoning & Continuing to Grow)

  4th Round Hypothesis (If third round worked): The model should be a CNN. The CNN should have 5 convolutional layers. Use Leaky ReLU activation for all layers. Use dropout regularization with a rate of 0.5.

  5th Round Hypothesis (If fourth round didn't work):  The model should be a CNN. The CNN should have 5 convolutional layers. Use Leaky ReLU activation for all layers. Use dropout regularization with a rate of 0.3. (Reasoning: As regularisation rate of 0.5 didn't work, we only change a new regularisation and keep the other elements that worked)    

  Sample JSON Output:
  [
    {
      "hypothesis": "The CNN should have 3 convolutional layers.",
      "reason": "Three convolutional layers are often sufficient to capture spatial features in the data without making the model overly complex."
    },
    {
      "hypothesis": "The CNN should have 5 convolutional layers.",
      "reason": "Five convolutional layers can help in capturing more intricate spatial features, potentially improving the model's performance on complex datasets."
    },
    {
      "hypothesis": "The CNN should use residual connections.",
      "reason": "Residual connections can help mitigate the vanishing gradient problem, facilitating the training of deeper networks."
    },
    {
      "hypothesis": "The CNN should include a fully connected layer at the end.",
      "reason": "A fully connected layer at the end can integrate features extracted by the convolutional layers and provide a robust output for classification tasks."
    }
  ]

factor_hypothesis_specification: |-
  Additional Specifications:
    Hypotheses should grow and evolve based on the previous hypothesis. If there is no previous hypothesis, start with something simple. Gradually build up upon previous hypotheses and feedback.
    Ensure that the hypothesis focuses on the creation and selection of factors in quantitative finance. Each hypothesis should address specific factor characteristics such as type (momentum, value, quality), calculation methods, or inclusion criteria. Avoid hypotheses related to model architecture or optimization processes.

  Sample Hypotheses (Only learn from the format as these are not the knowledge):
    - "Include a momentum factor based on the last 12 months' returns."
    - "Add a value factor calculated as the book-to-market ratio."
    - "Incorporate a quality factor derived from return on equity (ROE)."
    - "Use a volatility factor based on the standard deviation of returns over the past 6 months."
    - "Include a sentiment factor derived from news sentiment scores."
    - "The momentum factor should be calculated using a 6-month look-back period."
    - "Combine value and momentum factors using a weighted average approach."
    - "Filter stocks by market capitalization before calculating the factors."

factor_experiment_output_format: |-
  The output should follow JSON format. The schema is as follows:
  {
      "factor name 1": {
          "description": "description of factor 1",
          "formulation": "latex formulation of factor 1",
          "variables": {
              "variable or function name 1": "description of variable or function 1",
              "variable or function name 2": "description of variable or function 2"
          }
      },
      "factor name 2": {
          "description": "description of factor 1",
          "formulation": "latex formulation of factor 2",
          "variables": {
              "variable or function name 1": "description of variable or function 1",
              "variable or function name 2": "description of variable or function 2"
          }
      }
      # Don't add ellipsis (...) or any filler text that might cause JSON parsing errors here!
  }

model_experiment_output_format: |-
  So far please only design one model to test the hypothesis!
  The output should follow JSON format. The schema is as follows: 
  {
    "model_name (The name of the model)": {
        "description": "A detailed description of the model",
        "architecture": "A detailed description of the model's architecture, e.g., neural network layers or tree structures",
        "hyperparameters": {
            "hyperparameter_name_1": "value of hyperparameter 1",
            "hyperparameter_name_2": "value of hyperparameter 2",
            "hyperparameter_name_3": "value of hyperparameter 3"
        },
        "model_type": "Tabular or TimeSeries"  # Should be one of "Tabular" or "TimeSeries"
    }
  }
  
factor_feedback_generation:
  system: |-
    You are a professional result analysis assistant on data driven R&D.
    The task is described in the following scenario:
    {{ scenario }}
    You will receive a hypothesis, multiple tasks with their factors, and some results.
    Your feedback should specify whether the current result supports or refutes the hypothesis, compare it with previous SOTA results, and suggest improvements or new directions.
    Please provide detailed and constructive feedback for the future exploration.
    Please respond in JSON format, and example JSON Structure for Result Analysis:
    {
      "Observations": "Your overall observations here",
      "Feedback for Hypothesis": "Observations related to the hypothesis",
      "New Hypothesis": "Put your new hypothesis here.",
      "Reasoning": "Provide reasoning for the hypothesis here.",
      "Replace Best Result": "yes or no"
    }
  user: |-
    Target hypothesis: 
    {{ hypothesis_text }}
    Tasks and Factors:
    {{ task_details }}
    Combined Results: 
    {{ combined_result }}
    Analyze the combined result in the context of its ability to:
    1. Support or refute the hypothesis.
    2. Show improvement or deterioration compared to the last experiment.
    3. Demonstrate positive or negative effects when compared to Alpha158.

    Evaluation Metrics Explanations:
    Below are the financial meanings of each metric, which should be used to judge the results:

    - Rank ICIR: Evaluates the stability and average level of Rank IC. Rank ICIR = mean(Rank IC) / std(Rank IC).
    - 1day.excess_return_without_cost.max_drawdown: Measures the maximum loss from a peak to a trough without considering transaction costs.
    - 1day.excess_return_without_cost.information_ratio: Evaluates the excess return per unit of risk without considering transaction costs.
    - 1day.excess_return_with_cost.max_drawdown: Measures the maximum loss from a peak to a trough considering transaction costs.
    - 1day.excess_return_without_cost.annualized_return: Annualized return without considering transaction costs.
    - 1day.excess_return_with_cost.annualized_return: Annualized return considering transaction costs.
    - IC: Measures the correlation between predicted returns (\hat{y}) and actual returns (y), using Pearson correlation.
    - 1day.excess_return_with_cost.information_ratio: Evaluates the excess return per unit of risk considering transaction costs.

    When judging the results, prioritize metrics that consider transaction costs (with cost), as they provide a more accurate representation of real-world performance. Among these, the annualized return considering transaction costs is particularly important as it gives a clear picture of long-term profitability.
    Provide detailed feedback and recommend whether to replace the best result if the new factor proves superior.

model_feedback_generation:
  system: |-
    You are a professional result analysis assistant. You will receive a result and a hypothesis.
    Your task is to provide feedback on how well the result supports or refutes the hypothesis by judging from the observation of performance increase or decrease.
    Please provide detailed and constructive feedback.
    Example JSON Structure for Result Analysis:
    {
      "Observations": "Your overall observations here",
      "Feedback for Hypothesis": "Observations related to the hypothesis",
      "New Hypothesis": "Put your new hypothesis here.",
      "Reasoning": "Provide reasoning for the hypothesis here.",
      "Decision": <true or false>,
    }
  user: |-
    We are in an experiment of finding hypothesis and validating or rejecting them so that in the end we have a powerful model generated.
    Here are the context: {{context}}. 

    {% if last_hypothesis %} 
    Last Round Information:
    Hypothesis: {{last_hypothesis.hypothesis}}
    Task: {{last_task}}
    Result: {{last_result}}
    {% else %}
    This is the first round. No previous information available. As long as the performance is reasonable, treat it as successful. Do not set the threshold too high.  
    {% endif %} 
    
    Now let's come to this round. You will receive the result and you will evaluate if the performance increases or decreases. 
    Hypothesis: {{hypothesis.hypothesis}}
    Relevant Reasoning: {{hypothesis.reason}}
    Result: {{exp.result}}

    Compare and observe. Which result has a better return and lower risk? If the performance increases, the hypothesis should be considered positive (working). 
    Hence, with the hypotheses, relevant reasoning, and results in mind (comparison), provide detailed and constructive feedback and suggest a new hypothesis. 
